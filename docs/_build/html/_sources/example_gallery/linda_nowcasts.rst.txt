
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "example_gallery/linda_nowcasts.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_example_gallery_linda_nowcasts.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_example_gallery_linda_nowcasts.py:


LINDA nowcasts
==============

This example shows how to compute and plot a deterministic and ensemble LINDA
nowcasts using Swiss radar data.

.. GENERATED FROM PYTHON SOURCE LINES 10-24

.. code-block:: default


    from datetime import datetime
    import warnings

    warnings.simplefilter("ignore")

    import matplotlib.pyplot as plt

    from pysteps import io, rcparams
    from pysteps.motion.lucaskanade import dense_lucaskanade
    from pysteps.nowcasts import linda, sprog, steps
    from pysteps.utils import conversion, dimension, transformation
    from pysteps.visualization import plot_precip_field








.. GENERATED FROM PYTHON SOURCE LINES 25-27

Read the input rain rate fields
-------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 27-62

.. code-block:: default


    date = datetime.strptime("201701311200", "%Y%m%d%H%M")
    data_source = "mch"

    # Read the data source information from rcparams
    datasource_params = rcparams.data_sources[data_source]

    # Find the radar files in the archive
    fns = io.find_by_date(
        date,
        datasource_params["root_path"],
        datasource_params["path_fmt"],
        datasource_params["fn_pattern"],
        datasource_params["fn_ext"],
        datasource_params["timestep"],
        num_prev_files=2,
    )

    # Read the data from the archive
    importer = io.get_method(datasource_params["importer"], "importer")
    reflectivity, _, metadata = io.read_timeseries(
        fns, importer, **datasource_params["importer_kwargs"]
    )

    # Convert reflectivity to rain rate
    rainrate, metadata = conversion.to_rainrate(reflectivity, metadata)

    # Upscale data to 2 km to reduce computation time
    rainrate, metadata = dimension.aggregate_fields_space(rainrate, metadata, 2000)

    # Plot the most recent rain rate field
    plt.figure()
    plot_precip_field(rainrate[-1, :, :])
    plt.show()




.. image-sg:: /example_gallery/images/sphx_glr_linda_nowcasts_001.png
   :alt: mm/h
   :srcset: /example_gallery/images/sphx_glr_linda_nowcasts_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 63-65

Estimate the advection field
----------------------------

.. GENERATED FROM PYTHON SOURCE LINES 65-69

.. code-block:: default


    # The advection field is estimated using the Lucas-Kanade optical flow
    advection = dense_lucaskanade(rainrate, verbose=True)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Computing the motion field with the Lucas-Kanade method.
    --- 5 outliers detected ---
    --- LK found 176 sparse vectors ---
    --- 63 samples left after declustering ---
    --- total time: 0.40 seconds ---




.. GENERATED FROM PYTHON SOURCE LINES 70-72

Deterministic nowcast
---------------------

.. GENERATED FROM PYTHON SOURCE LINES 72-118

.. code-block:: default


    # Compute 30-minute LINDA nowcast with 8 parallel workers
    # Restrict the number of features to 15 to reduce computation time
    nowcast_linda = linda.forecast(
        rainrate,
        advection,
        6,
        max_num_features=15,
        add_perturbations=False,
        num_workers=8,
        measure_time=True,
    )[0]

    # Compute S-PROG nowcast for comparison
    rainrate_db, _ = transformation.dB_transform(
        rainrate, metadata, threshold=0.1, zerovalue=-15.0
    )
    nowcast_sprog = sprog.forecast(
        rainrate_db[-3:, :, :],
        advection,
        6,
        n_cascade_levels=6,
        R_thr=-10.0,
    )

    # Convert reflectivity nowcast to rain rate
    nowcast_sprog = transformation.dB_transform(
        nowcast_sprog, threshold=-10.0, inverse=True
    )[0]

    # Plot the nowcasts
    fig = plt.figure(figsize=(9, 4))
    ax = fig.add_subplot(1, 2, 1)
    plot_precip_field(
        nowcast_linda[-1, :, :],
        title="LINDA (+ 30 min)",
    )

    ax = fig.add_subplot(1, 2, 2)
    plot_precip_field(
        nowcast_sprog[-1, :, :],
        title="S-PROG (+ 30 min)",
    )

    plt.show()




.. image-sg:: /example_gallery/images/sphx_glr_linda_nowcasts_002.png
   :alt: LINDA (+ 30 min), mm/h, S-PROG (+ 30 min), mm/h
   :srcset: /example_gallery/images/sphx_glr_linda_nowcasts_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Computing LINDA nowcast
    -----------------------

    Inputs
    ------
    dimensions:           320x355
    number of time steps: 3

    Methods
    -------
    nowcast type:         deterministic
    feature detector:     blob
    extrapolator:         semilagrangian
    kernel type:          anisotropic

    Parameters
    ----------
    number of time steps:       6
    ARI model order:            1
    localization window radius: 64.0

    Detecting features... found 15 blobs in 0.81 seconds.
    Transforming to Lagrangian coordinates... 0.08 seconds.
    Estimating the first convolution kernel... 8.74 seconds.
    Estimating the ARI(p,1) parameters... 0.15 seconds.
    Estimating the second convolution kernel... 8.13 seconds.
    Computing nowcast for time step 1... 0.36 seconds.
    Computing nowcast for time step 2... 0.37 seconds.
    Computing nowcast for time step 3... 0.37 seconds.
    Computing nowcast for time step 4... 0.37 seconds.
    Computing nowcast for time step 5... 0.37 seconds.
    Computing nowcast for time step 6... 0.37 seconds.
    Computing S-PROG nowcast:
    -------------------------

    Inputs:
    -------
    input dimensions: 320x355

    Methods:
    --------
    extrapolation:          semilagrangian
    bandpass filter:        gaussian
    decomposition:          fft
    conditional statistics: no
    probability matching:   cdf
    FFT method:             numpy
    domain:                 spatial

    Parameters:
    -----------
    number of time steps:     6
    parallel threads:         1
    number of cascade levels: 6
    order of the AR(p) model: 2
    precip. intensity threshold: -10
    ************************************************
    * Correlation coefficients for cascade levels: *
    ************************************************
    -----------------------------------------
    | Level |     Lag-1     |     Lag-2     |
    -----------------------------------------
    | 1     | 0.999163      | 0.996708      |
    -----------------------------------------
    | 2     | 0.997665      | 0.989434      |
    -----------------------------------------
    | 3     | 0.990083      | 0.965014      |
    -----------------------------------------
    | 4     | 0.944684      | 0.846046      |
    -----------------------------------------
    | 5     | 0.745174      | 0.544617      |
    -----------------------------------------
    | 6     | 0.265468      | 0.124791      |
    -----------------------------------------
    ****************************************
    * AR(p) parameters for cascade levels: *
    ****************************************
    ------------------------------------------------------
    | Level |    Phi-1     |    Phi-2     |    Phi-0     |
    ------------------------------------------------------
    | 1     | 1.919792     | -0.921400    | 0.015897     |
    ------------------------------------------------------
    | 2     | 1.867768     | -0.872140    | 0.033414     |
    ------------------------------------------------------
    | 3     | 1.736251     | -0.753642    | 0.092338     |
    ------------------------------------------------------
    | 4     | 1.352003     | -0.431169    | 0.295928     |
    ------------------------------------------------------
    | 5     | 0.763049     | -0.023987    | 0.666678     |
    ------------------------------------------------------
    | 6     | 0.249956     | 0.058435     | 0.962472     |
    ------------------------------------------------------
    Starting nowcast computation.
    Computing nowcast for time step 1... done.
    Computing nowcast for time step 2... done.
    Computing nowcast for time step 3... done.
    Computing nowcast for time step 4... done.
    Computing nowcast for time step 5... done.
    Computing nowcast for time step 6... done.




.. GENERATED FROM PYTHON SOURCE LINES 119-124

The above figure shows that the filtering scheme implemented in LINDA preserves
small-scale and band-shaped features better than S-PROG. This is because the
former uses a localized elliptical convolution kernel instead of the
cascade-based autoregressive process, where the parameters are estimated over
the whole domain.

.. GENERATED FROM PYTHON SOURCE LINES 126-128

Probabilistic nowcast
---------------------

.. GENERATED FROM PYTHON SOURCE LINES 128-176

.. code-block:: default


    # Compute 30-minute LINDA nowcast ensemble with 40 members and 8 parallel workers
    nowcast_linda = linda.forecast(
        rainrate,
        advection,
        6,
        max_num_features=15,
        add_perturbations=True,
        num_ens_members=40,
        num_workers=8,
        measure_time=True,
    )[0]

    # Compute 40-member STEPS nowcast for comparison
    nowcast_steps = steps.forecast(
        rainrate_db[-3:, :, :],
        advection,
        6,
        40,
        n_cascade_levels=6,
        R_thr=-10.0,
        mask_method="incremental",
        kmperpixel=2.0,
        timestep=datasource_params["timestep"],
        vel_pert_method=None,
    )

    # Convert reflectivity nowcast to rain rate
    nowcast_steps = transformation.dB_transform(
        nowcast_steps, threshold=-10.0, inverse=True
    )[0]

    # Plot two ensemble members of both nowcasts
    fig = plt.figure()
    for i in range(2):
        ax = fig.add_subplot(2, 2, i + 1)
        ax = plot_precip_field(
            nowcast_linda[i, -1, :, :], geodata=metadata, colorbar=False, axis="off"
        )
        ax.set_title(f"LINDA Member {i+1}")

    for i in range(2):
        ax = fig.add_subplot(2, 2, 3 + i)
        ax = plot_precip_field(
            nowcast_steps[i, -1, :, :], geodata=metadata, colorbar=False, axis="off"
        )
        ax.set_title(f"STEPS Member {i+1}")




.. image-sg:: /example_gallery/images/sphx_glr_linda_nowcasts_003.png
   :alt: LINDA Member 1, LINDA Member 2, STEPS Member 1, STEPS Member 2
   :srcset: /example_gallery/images/sphx_glr_linda_nowcasts_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Computing LINDA nowcast
    -----------------------

    Inputs
    ------
    dimensions:           320x355
    number of time steps: 3

    Methods
    -------
    nowcast type:         ensemble
    feature detector:     blob
    extrapolator:         semilagrangian
    kernel type:          anisotropic

    Parameters
    ----------
    number of time steps:       6
    ARI model order:            1
    localization window radius: 64.0
    error dist. window radius:  48.0
    error ACF window radius:    80.0
    ensemble size:              40
    parallel workers:           8
    seed:                       None

    Detecting features... found 15 blobs in 0.81 seconds.
    Transforming to Lagrangian coordinates... 0.07 seconds.
    Estimating the first convolution kernel... 8.92 seconds.
    Estimating the ARI(p,1) parameters... 0.14 seconds.
    Estimating the second convolution kernel... 8.09 seconds.
    Estimating forecast errors... 0.56 seconds.
    Estimating perturbation parameters... 35.10 seconds.
    Computing STEPS nowcast:
    ------------------------

    Inputs:
    -------
    input dimensions: 320x355
    km/pixel:         2
    time step:        5 minutes

    Methods:
    --------
    extrapolation:          semilagrangian
    bandpass filter:        gaussian
    decomposition:          fft
    noise generator:        nonparametric
    noise adjustment:       no
    velocity perturbator:   None
    conditional statistics: no
    precip. mask method:    incremental
    probability matching:   cdf
    FFT method:             numpy
    domain:                 spatial

    Parameters:
    -----------
    number of time steps:     6
    ensemble size:            40
    parallel threads:         1
    number of cascade levels: 6
    order of the AR(p) model: 2
    precip. intensity threshold: -10
    ************************************************
    * Correlation coefficients for cascade levels: *
    ************************************************
    -----------------------------------------
    | Level |     Lag-1     |     Lag-2     |
    -----------------------------------------
    | 1     | 0.999163      | 0.996708      |
    -----------------------------------------
    | 2     | 0.997665      | 0.989434      |
    -----------------------------------------
    | 3     | 0.990083      | 0.965014      |
    -----------------------------------------
    | 4     | 0.944684      | 0.846046      |
    -----------------------------------------
    | 5     | 0.745174      | 0.544617      |
    -----------------------------------------
    | 6     | 0.265468      | 0.124791      |
    -----------------------------------------
    ****************************************
    * AR(p) parameters for cascade levels: *
    ****************************************
    ------------------------------------------------------
    | Level |    Phi-1     |    Phi-2     |    Phi-0     |
    ------------------------------------------------------
    | 1     | 1.919792     | -0.921400    | 0.015897     |
    ------------------------------------------------------
    | 2     | 1.867768     | -0.872140    | 0.033414     |
    ------------------------------------------------------
    | 3     | 1.736251     | -0.753642    | 0.092338     |
    ------------------------------------------------------
    | 4     | 1.352003     | -0.431169    | 0.295928     |
    ------------------------------------------------------
    | 5     | 0.763049     | -0.023987    | 0.666678     |
    ------------------------------------------------------
    | 6     | 0.249956     | 0.058435     | 0.962472     |
    ------------------------------------------------------
    Starting nowcast computation.
    Computing nowcast for time step 1... done.
    Computing nowcast for time step 2... done.
    Computing nowcast for time step 3... done.
    Computing nowcast for time step 4... done.
    Computing nowcast for time step 5... done.
    Computing nowcast for time step 6... done.




.. GENERATED FROM PYTHON SOURCE LINES 177-183

The above figure shows the main difference between LINDA and STEPS. In
addition to the convolution kernel, another improvement in LINDA is a
localized perturbation generator using the short-space Fourier transform
(SSFT) and a spatially variable marginal distribution. As a result, the
LINDA ensemble members preserve the anisotropic and small-scale structures
considerably better than STEPS.

.. GENERATED FROM PYTHON SOURCE LINES 183-186

.. code-block:: default


    plt.tight_layout()
    plt.show()



.. image-sg:: /example_gallery/images/sphx_glr_linda_nowcasts_004.png
   :alt: linda nowcasts
   :srcset: /example_gallery/images/sphx_glr_linda_nowcasts_004.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 3 minutes  26.521 seconds)


.. _sphx_glr_download_example_gallery_linda_nowcasts.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: linda_nowcasts.py <linda_nowcasts.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: linda_nowcasts.ipynb <linda_nowcasts.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
